version=12;#Changelog:#v12: added srM histories for each player#v11: made players(:,3)=srComp-srM#v10: updated definition of srComp-->srComp=srT*coop^6 based on Tyler's comment#v9: - added sortedness = dot(rankT-meanRank, rankM-meanRank)/norm(rankT)^2#    - shuffle players before assigning rankM so that rankT != rankM#    - added better comments to remember what is stored in large matrices#    - rankT based on#v8: - added srComp (composite score) = srT*coop#      stored in players(:,8)#    - added matches played counter to players#      stored in players(:,9).#v7: cleaned up srStats to allow for easier plotting/printing#v6: calculating expected scores based on true team ratings to allow for upsets#v5: changes to allow animation#v4: added cooperation rating to players(:,7).#   team rating = mean(srT)*prod(coop) for the players on that team#v3: added ranks to players(:, 4:6)#v2: changed match making to selecting adjacent members of sorted players matrix#This program is to create a simplified simulation of applying Elo rankings#to individuals based on the performance of their team with randomly#matched teammates, akin to Overwatch. Goals are to see how many matches it#takes to get player rankings reasonably close to their "true" rankings.#Assume that every player begins with a true skill rating (srT) that is constant and chosen#from a normal distribution and a measured skill rating (srM) that is initialized#to the mean of the normal dist. Matches are simulated by choosing two teams#of 6 players that are close in srM and then awarding a win to the team with#the greater average srT. Individual ranks are then to be adjusted#based on the average srM difference according to the Elo system.#pseudo-code:#- create matrix with entires for true and measured skill rating of n players#- create true SR entries from a normal dist.#- create measured SR entries equal to the mean of the true rank dist#- select two teams of 6 players#  - select a random "seed" player#  - select another random player and check if their rank within a given range#    of the seed. If they are, put them on one of the teams. If they are not,#    select another random player and repeat.#- Calculate the average srT for each team.#- Let the team with the higher average srT win#  - adjust the individual srM based on the average srM difference#- repeat above stepstic();n = 1000; #number of players in the poolmeanRank = (n+1)/2;matchesPerPlayer = 200; #average number of matches per player to simulateteamSize = 6;matches = round(matchesPerPlayer*n/(2*teamSize)); #number of matches to playave = 1500; #average player srTsd = 350; #std deviation of srTcoopSd = 0.05;matchSpread = sd; #largest allowed srM difference from seed playerk=32; #Elo k parameterplayersHistory=zeros(n,0); #srM history for each player#players contains: (:,1) srT - true skill rating#players contains: (:,2) srM - meaasured skill rating#players contains: (:,3) srComp - srM#players contains: (:,4) rankT - true rank. higher rank = better player#players contains: (:,5) rankM - measured rank#players contains: (:,6) rankT-rankM#players contains: (:,7) coop - cooperation factor#players contains: (:,8) srComp - composite score#players contains: (:,9) matches playedplayers = zeros(n,9); #srT, srM, srT-srM, rankT, rankM, rankT-rankM, coop, srComp, matches playedplayers(:,1) = normrnd(ave, sd, n,1); #set srTplayers(:,2) = ave; #initialize srMplayers(:,7) = normrnd(1,coopSd,n,1); #set cooperation ratingsplayers(:,8) = players(:,1) .* (players(:,7).^6); #set srCompplayers = sortrows(players, 8); #sort by srCompplayers(:,4) = [1:n]'; #set rankT#shuffle players so that rankM != rankTshuffleOrder = randperm(n);players=players(shuffleOrder,:);updatePeriod = round(matches/100); #how many matches pass between updating srStats and players(:,3)#srStats contains: (:,1) |sr diff| ave#srStats contains: (:,2) sr diff std dev#srStats contains: (:,3) |rank diff| ave#srStats contains: (:,4) rank diff std dev#srStats contains: (:,5) match number#srStats contains: (:,6) sortednesssrStats = zeros(0,6); #|sr diff| ave, sr diff std dev, |rank diff| ave, rank diff std dev, match number, sortedness#set(0, 'defaultfigurevisible', 'off'); #hide plot display to run faster. does not work without osmesafor j = 1:matches    #update stats according to updatePeriod  if ( (mod(j,updatePeriod)==0) || (j==1) )    players(:,5) = [1:n]'; #set rankM for the current stat update    players(:,3) = players(:,8) - players(:,2); #set sr difference    players(:,6) = players(:,4) - players(:,5);# set rank difference        srStatsUpdate = zeros(1,6); #temporary place to store new line before concatenating to srStats    srStatsUpdate(1,1) = mean(abs(players(:,3)));    srStatsUpdate(1,2) = std(players(:,3));    srStatsUpdate(1,3) = mean(abs(players(:,6)));    srStatsUpdate(1,4) = std(players(:,6));    srStatsUpdate(1,5) = j;    ranksT = players(:,4)-meanRank;    ranksM = players(:,5)-meanRank;    srStatsUpdate(1,6) = dot(ranksT, ranksM)/norm(ranksT)^2;        srStats = [srStats; srStatsUpdate]; #tack on new line of stats        #plotStatsCoop (players, srStats, n, matches, coopSd, j);    #filename=sprintf('output/%06d.png',j);    #print(filename);  endif    #match contains: (:,1) player index  #match contains: (:,2) team#  #match contains: (:,3) player srT  #match contains: (:,4) player srM  #match contains: (:,5) player coop  #match contains: (:,6) player rankT  match = zeros(teamSize*2,6);    picks = 0; #number of players chosen for the current match    #teams contains: (:,1) team rating  #teams contains: (:,2) mean srM  #teams contains: (:,3) score  #teams contains: (:,4) expected score  teams = zeros(2,4);    r = zeros(2,2); #rSrT, rSrM: transformed team ratings, for ease of calculations later    #create the match  seed = randi(n-(2*teamSize-1));  for i = 1:2*teamSize    match(i,:) = [seed + i-1, mod(i-1,2)+1, players(seed + i-1, 1:2), players(seed + i-1, 7), players(seed + i-1, 4)];  endfor    #determine team ratings  match=sortrows(match,2); #sort by team #  teams(1,1:2) = mean(match(1:teamSize, 3:4)); #srT and srM for team 1  teams(2,1:2) = mean(match(teamSize+1:teamSize*2, 3:4)); # " " team 2  teams(:,1) = teams(:,1) .* [prod(match(1:teamSize, 5)); prod(match(teamSize+1:teamSize*2, 5))]; #coop factor  #calculate transformed team ratings (true and measured)  r(1,1) = 10^(teams(1,1)/400);  r(2,1) = 10^(teams(2,1)/400);  r(1,2) = 10^(teams(1,2)/400);  r(2,2) = 10^(teams(2,2)/400);  #calculate real score for each team  teams(1,3) = r(1,1)/(r(1,1)+r(2,1));  teams(2,3) = r(2,1)/(r(1,1)+r(2,1));  #assign score of 1 to the winning team based on real score  if (teams(1,3) > rand())    teams(1,3) = 1;    teams(2,3) = 0;    else    teams(1,3) = 0;    teams(2,3) = 1;  endif  #calculate expected score for each team  teams(1,4) = r(1,2)/(r(1,2)+r(2,2));  teams(2,4) = r(2,2)/(r(1,2)+r(2,2));  #update Elo ratings for each player that was in the match  #update matches played counter " "  for i=1:size(match,1)    players(match(i,1),2) = players(match(i,1),2) + k * (teams(match(i,2),3) - teams(match(i,2),4));    players(match(i,1),9)++;    playersHistory(match(i,6), players(match(i,1),9)) = players(match(i,1),2);  endfor  #sort players by srM to prepare for next matchmaking  players = sortrows(players,2);    endforprintf(num2str(toc()));printf("\n");